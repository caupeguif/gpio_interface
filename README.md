# GPIO_INTERFACE
Este proyecto se centra en el diseño y construcción de un microprocesador basado en la arquitectura RISC-V, específicamente con la especificación RV32I. Su desarrollo se estructura mediante la integración de múltiples módulos funcionales, cada uno diseñado para cumplir un propósito específico dentro del sistema. Una pieza clave de esta arquitectura es el módulo GPIO Interface, que constituye la base del diseño y se encarga de proporcionar una interfaz versátil para la comunicación con hardware externo. Este módulo, con capacidad para manejar hasta 16 pines configurables, permite definir cada pin como entrada o salida, además de integrar funciones avanzadas como la generación de interrupciones por cambios de estado, interrupciones por flanco de subida o bajada y soporte de funciones avanzadas como SPI, PWM y UART

El desarrollo de este proyecto siguió un enfoque estructurado y metódico, basado en la creación e implementación de una serie de diagramas de bloques que desempeñaron un papel clave en la construcción del módulo GPIO_INTERFACE. Inicialmente, se diseñó un esquema básico para un único pin GPIO, que sirvió como base para establecer las funcionalidades esenciales de entrada, salida y configuración. Este diseño inicial fue concebido con un enfoque modular, lo que permitió reutilizarlo de manera eficiente al instanciarlo múltiples veces en módulos superiores, simplificando así su integración en el módulo principal GPIO_INTERFACE.

  ![image](https://github.com/user-attachments/assets/975877bc-90f6-4f59-b832-b1a6f6795e3a)
     
Tras completar el diseño básico, se avanzó hacia un modelo más complejo que incorporó funcionalidades avanzadas, como la detección de interrupciones por flancos ascendentes y descendentes. Este diseño extendido añadió la capacidad de identificar eventos a nivel de hardware, permitiendo al sistema responder en tiempo real a cambios en los pines. Esta etapa fue crucial para sentar las bases del controlador de interrupciones que se integraría en el sistema completo

  ![image](https://github.com/user-attachments/assets/3cdcee00-e0e2-422d-9712-56d8243daa10)

Con estos dos diseños fundamentales como punto de partida, se procedió a desarrollar los módulos intermedios que conforman el GPIO_INTERFACE. Entre estos módulos se incluyen el manejo de datos de entrada y salida, que gestiona la comunicación entre los pines y el sistema; la configuración de direcciones, que define si los pines actúan como entradas o salidas; y el controlador de interrupciones, que procesa eventos generados en los pines y los transmite al sistema principal. Como punto de partida se hizo uso del siguiente diagrama: 

  ![image](https://github.com/user-attachments/assets/b4613daf-3eab-43aa-8a95-2d8ff423d998)

El diseño abarca los elementos especificados en los requisitos, incluyendo la implementación de 16 pines GPIO, los cuales pueden configurarse de forma individual como entrada o salida a través del módulo gpio_dir. Asimismo, incorpora soporte para interrupciones externas sensibles a flancos (ascendente y descendente, aunque faltaria mejorarla y corregir algunas cosas) y la generación de interrupciones por cambios de estado en todos los pines GPIO, características desarrolladas en el módulo gpio_ctrl y validadas mediante simulaciones exhaustivas. Adicionalmente, se llevaron a cabo pruebas específicas para comprobar el funcionamiento de los pines con funciones especiales, como SPI, I2C, UART y PWM, empleando casos diseñados para activar estas configuraciones y verificar el correcto funcionamiento de estos.

Después de llevar a cabo la implementación utilizando el lenguaje de descripción de hardware Verilog, se obtuvo como resultado la vista RTL del diseño, la cual proporciona una representación gráfica detallada de los componentes y su interconexión. Este paso es fundamental para verificar la estructura y funcionalidad del diseño antes de proceder con las etapas posteriores de síntesis y layout.

  ![image](https://github.com/user-attachments/assets/d29f8a9d-077e-4742-a496-ef0006c35b9d)
  
# RESULTADOS DE PRUEBAS (TESTBENCH)

Como primer prueba se realizó el testbench para el módulo `gpio_npins` y así validar su correcto funcionamiento en diversos escenarios. En el primer caso, se demostró que los pines configurados como entrada (`dir_in = 0`) reflejan directamente los valores de `gpio_pins` en la salida `gpio_pins_out`. En el segundo caso, al configurar algunos pines como salida (`dir_in` con ciertos bits en `1`), se observó una combinación adecuada de valores de entrada y salida según la configuración. En el tercer caso, con todos los pines configurados como salida (`dir_in = 1`), la salida reflejó correctamente los valores de `data_in`. En el cuarto caso, se validó que los cambios en `data_in` se propagan correctamente a los pines configurados como salida. Finalmente, al activar el reset, se confirmó que la salida se restablece a `0` y que el módulo retoma su funcionalidad normal tras liberar el reset.

  ![image](https://github.com/user-attachments/assets/271f672c-ae2e-4b96-9534-922f8a26969c)

Los resultados del testbench para el módulo `gpio_spins` validan el correcto funcionamiento y la gestión de los pines GPIO bajo diversas configuraciones. En el **Caso 1**, sin funciones especiales habilitadas, se verificó que los valores de entrada `gpio_pins_in` se propagaran directamente a la salida `gpio_pins_out`, asegurando un comportamiento estándar. En el **Caso 2**, al habilitar la función PWM Output A0, se comprobó que el pin 9 reflejara correctamente el valor esperado desde `data_in`, incluso ante intentos de sobrescritura. El **Caso 3** evaluó la función SPI, verificando que los pines 4-7 mantuvieran los valores definidos en `data_in` sin permitir modificaciones externas. En el **Caso 4**, al habilitar la función I2C, los pines 2-3 fueron configurados correctamente y se mantuvieron en sus valores esperados. Para el **Caso 5**, se probó la función UART, asegurando que los pines 0-1 permanecieran en el estado configurado. Finalmente, en el **Caso 6**, con todas las funciones especiales deshabilitadas, los pines retomaron su comportamiento normal, replicando los valores de entrada en la salida.

Una función adicional implementada fue la protección de los pines asignados a funciones especiales. Inicialmente, se observó que, al reasignar valores a los pines mientras estas funciones estaban activas, los pines podían cambiar su estado indebidamente. Para resolver esta limitación, se incorporó una lógica de protección que impide modificaciones en los pines asociados a funciones especiales mientras estas están habilitadas. Esto asegura la integridad de las configuraciones y refuerza la robustez del diseño.

![image](https://github.com/user-attachments/assets/2cd35680-9135-4c01-90c6-c6842177e554)

Los resultados del testbench para el módulo `gpio_ctrl` demuestran el comportamiento esperado en la generación de interrupciones con base en máscaras configurables y detección de cambios en los pines GPIO. En el **Caso 1**, con las máscaras de interrupción deshabilitadas y sin cambios en los pines, no se generaron interrupciones, validando el comportamiento pasivo del módulo en ausencia de eventos relevantes. En el **Caso 2**, al habilitar la máscara para el pin 14 asociado a `irq_int0`, se generaron interrupciones al detectar un flanco de subida y uno de bajada en dicho pin, confirmando la sensibilidad adecuada a los eventos configurados. En el **Caso 3**, se activó la máscara para el pin 15, asociado a `irq_int1`, y se observó un comportamiento similar, respondiendo correctamente a los cambios de estado en este pin. Finalmente, en el **Caso 4**, se configuraron máscaras para todos los pines y se probaron múltiples cambios en todos ellos, verificando que el módulo detectara adecuadamente los eventos de pin change y generara `irq_pinchange` en consecuencia. Este último caso demuestra la capacidad del módulo para gestionar interrupciones de cambio de estado en todos los pines simultáneamente.

![image](https://github.com/user-attachments/assets/f3c8f657-a418-495e-9c89-c07005a21c44)

Los resultados del testbench para el módulo `gpio_dir` validan el correcto funcionamiento de la configuración de direcciones para los pines GPIO en diferentes escenarios. En el **Caso 1**, con la señal `write_enable` deshabilitada, los valores de entrada en `dir_in` no afectaron el estado de la salida `gpio_dir`, manteniéndose en su estado inicial. En el **Caso 2**, al habilitar la escritura mediante `write_enable` y cambiar los valores de `dir_in` a `1111_0000_1111_0000`, se reflejó correctamente en `gpio_dir`, indicando que el módulo respondía adecuadamente a la configuración de los pines. En el **Caso 3**, con la escritura aún habilitada, se realizaron cambios adicionales en `dir_in`, que se propagaron correctamente a la salida, validando la capacidad del módulo para actualizar dinámicamente las configuraciones. Finalmente, en el **Caso 4**, al deshabilitar la escritura nuevamente, el módulo mantuvo el último estado configurado en `gpio_dir`, ignorando los nuevos valores en `dir_in`, asegurando la preservación del estado cuando no se permite escritura. Estos resultados confirman que el módulo cumple con su función de gestionar las configuraciones de dirección de los pines GPIO según lo esperado.

![image](https://github.com/user-attachments/assets/fc51d41e-6c32-4e1d-a296-4c11120e1713)

El testbench del módulo `gpio_data_in` valida su funcionalidad al identificar correctamente los valores de los pines configurados como entrada, dependiendo del estado de la señal `gpio_dir`. En el **Caso 1**, todos los pines están configurados como entrada (`gpio_dir = 0`), y el módulo refleja fielmente los valores de `gpio_pins` en `gpio_data_in`, confirmando su operación básica. En el **Caso 2**, se configura parte de los pines (0-3 y 8-11) como salida (`gpio_dir = 0000_1111_0000_1111`), y el módulo bloquea correctamente estos pines, reflejando únicamente los valores de los pines restantes como entrada. El **Caso 3** prueba un escenario extremo donde todos los pines están configurados como salida (`gpio_dir = 1111_1111_1111_1111`), y como resultado, `gpio_data_in` no refleja ningún valor, indicando que el módulo respeta las configuraciones de dirección. Finalmente, el **Caso 4** alterna entre entrada y salida en todos los pines (`gpio_dir = 1010_1010_1010_1010`), validando que el módulo gestiona correctamente configuraciones híbridas, reflejando únicamente los pines configurados como entrada. Estos resultados confirman que el diseño cumple con los requisitos para manejar valores de entrada en un entorno dinámico y configurable.

![image](https://github.com/user-attachments/assets/642a91ef-8338-49e1-951a-fba156e73d5b)

El testbench del módulo `gpio_data_out` evalúa su capacidad para gestionar correctamente los datos de salida en función de la señal de habilitación de escritura (`write_enable`). En el **Caso 1**, con la escritura deshabilitada (`write_enable = 0`), se observa que `gpio_data_out` permanece en cero independientemente del valor de `data_in`, validando que el módulo bloquea cambios en los datos de salida cuando la escritura no está activa. En el **Caso 2**, al habilitar la escritura (`write_enable = 1`), `gpio_data_out` refleja correctamente el valor de `data_in`, lo que confirma el funcionamiento esperado de la señal de control. El **Caso 3** verifica que el módulo responde dinámicamente a cambios en `data_in` mientras la escritura está habilitada, actualizando inmediatamente `gpio_data_out`. Finalmente, en el **Caso 4**, al deshabilitar nuevamente la escritura, `gpio_data_out` conserva su último estado, demostrando que el módulo mantiene la salida estable incluso ante cambios en `data_in` cuando la escritura no está activa. Estos resultados confirman que el diseño cumple con los requisitos de control de datos de salida de manera eficiente y robusta.

![image](https://github.com/user-attachments/assets/2d9feb04-ee5a-4615-a793-d5d661d2d3d4)

El testbench del módulo `gpio_interface` evalúa la integración completa de todos los submódulos que componen la interfaz GPIO, verificando su comportamiento en diferentes escenarios funcionales. En el **Caso 1**, se evalúa el estado inicial donde todos los pines están configurados como entrada, confirmando que los datos de entrada (`gpio_data_in`) se corresponden con el estado de los pines (`gpio_pins`). En el **Caso 2**, se habilita la escritura de datos (`write_data_enable = 1`) y se comprueba que los datos en `data_in` se reflejan correctamente en `gpio_data_out`. En el **Caso 3**, se prueba la generación de interrupciones por flanco de subida en un pin específico, activando las máscaras correspondientes y verificando que las señales `irq_int0` e `irq_pinchange` respondan adecuadamente. El **Caso 4** extiende esta funcionalidad a flancos de bajada, confirmando el correcto disparo de `irq_int1`.

En el **Caso 5**, se habilitan las funciones especiales para SPI, observando cómo los datos correspondientes a estas configuraciones se gestionan a través de `gpio_pins_out`. Posteriormente, en el **Caso 6**, se habilitan múltiples funciones especiales simultáneamente (I2C y UART), validando que la señal de salida refleja adecuadamente las restricciones impuestas por estas configuraciones. Finalmente, el **Caso 7** verifica que el módulo responde correctamente al reinicio (`reset`), restaurando su estado inicial y manteniendo la integridad de las señales involucradas. Este testbench demuestra la cohesión funcional de todos los submódulos y confirma que el diseño integra correctamente las funcionalidades requeridas.

![image](https://github.com/user-attachments/assets/c37deb14-227d-4173-a96c-dd2138e41429)

El análisis de temporización del diseño muestra que todas las restricciones especificadas se cumplen de manera exitosa. En términos de **setup**, el menor margen o slack negativo es de 0.605 ns, indicando que todas las señales llegan a tiempo para ser configuradas correctamente, sin endpoints fallidos entre los 409 analizados. Para **hold**, el slack más bajo es de 0.142 ns, lo que garantiza que las señales se mantienen estables durante el tiempo necesario, también sin endpoints fallidos. En cuanto al **ancho de pulso**, el peor slack registrado es de 4.045 ns, lo que asegura que las señales tienen una duración adecuada, sin problemas en los 164 endpoints evaluados. En resumen, el diseño cumple con todas las restricciones de temporización, confirmando su robustez y correcta implementación.

![image](https://github.com/user-attachments/assets/cc1f34fe-808b-4591-9adf-3e8812b799d7)

La tabla muestra los tiempos críticos y detalles de los caminos más importantes en el diseño, incluyendo el retardo total, retardo lógico, y retardo de la red para rutas entre señales específicas del diseño, como `gpio_pins_inst` y `gpio_pins_out`. Basándose en estos valores, se definieron las restricciones (`constraints`) de temporización para el diseño. Por ejemplo, se estableció un reloj principal de 100 MHz con un período de 10 ns, lo que define la base de la temporización. Para los puertos de entrada, como `gpio_pins`, `data_in`, y otros, se asignó un retardo de entrada de 1.5 ns (`set_input_delay`) para reflejar el tiempo que las señales externas tardan en estabilizarse después de un flanco del reloj. Similarmente, para los puertos de salida, como `gpio_pins_out` y `gpio_data_in`, se aplicó un retardo de salida de 2.4 ns (`set_output_delay`) para indicar el tiempo máximo permitido para que las señales lleguen a sus destinos externos. Estos valores aseguran que las señales cumplan con los márgenes de tiempo establecidos en el diseño para un funcionamiento correcto.

![image](https://github.com/user-attachments/assets/2423ea42-6dfe-44bf-869a-398d777b8237)
Se realizó una synthesis para encontrar la configuración adecuada que menor tamaño ocupe y que los tiempos de slack sean mejores.

![image](https://github.com/user-attachments/assets/6037741a-b4b7-4988-b3fe-8adb77ddb490)

El proyecto tiene dimensiones físicas claramente definidas, con un ancho de **122.020 µm** y un alto de **132.740 µm**, lo que resulta en una buena integración si se va a realizar en 130 nm. Algo en lo que se debe mejorar es la disposicion de los pines ya que la forma en la que está dispuesto no es la mas optima para el diseño final.

![image](https://github.com/user-attachments/assets/7bc73f60-f16d-4386-80d7-d508c0d7fe4d)
